use crate::{
    address_display::AddressDisplay, any_of::AnyOf, bitcoin_amount_display::BitcoinAmountDisplay,
    gray4_style::Gray4TextStyle, page_slider::PageSlider, palette::PALETTE, prelude::*,
    widget_list::WidgetList, HoldToConfirm,
};
use alloc::{format, string::ToString};
use embedded_graphics::{
    draw_target::DrawTarget,
    geometry::{Point, Size},
    pixelcolor::Rgb565,
};
use frostsnap_core::bitcoin_transaction::PromptSignBitcoinTx;
use frostsnap_fonts::{
    Gray4Font, NOTO_SANS_17_REGULAR, NOTO_SANS_18_LIGHT, NOTO_SANS_18_MEDIUM, NOTO_SANS_24_BOLD,
    WARNING_ICON,
};

// Font constants to match deviceui version
const FONT_PAGE_HEADER: &Gray4Font = &NOTO_SANS_18_LIGHT;
const FONT_CONFIRM_TITLE: &Gray4Font = &NOTO_SANS_18_MEDIUM;
const FONT_CONFIRM_TEXT: &Gray4Font = &NOTO_SANS_17_REGULAR;
const FONT_CAUTION_NOTE: &Gray4Font = &NOTO_SANS_18_MEDIUM;
const FONT_CAUTION_TITLE: &Gray4Font = &NOTO_SANS_24_BOLD;
const FONT_CAUTION_TEXT: &Gray4Font = &NOTO_SANS_17_REGULAR;

// Fee warning thresholds
/// High fee threshold in satoshis (0.001 BTC)
const HIGH_FEE_ABSOLUTE_THRESHOLD_SATS: u64 = 100_000;
/// High fee threshold as percentage of total sent amount (5%)
const HIGH_FEE_PERCENTAGE_THRESHOLD: u64 = 5;

// Hold-to-confirm timing
/// Time to hold for signing transaction (3 seconds)
const HOLD_TO_SIGN_TIME_MS: u32 = 3000;

/// Widget list that generates sign prompt pages
#[derive(Clone)]
pub struct SignPromptPageList {
    prompt: PromptSignBitcoinTx,
    total_pages: usize,
    rand_seed: u32,
}

/// Page widget for displaying amount to send
#[derive(frostsnap_macros::Widget)]
pub struct AmountPage {
    #[widget_delegate]
    center: Center<
        Column<(
            Text<Gray4TextStyle>,
            SizedBox<Rgb565>,
            BitcoinAmountDisplay,
            SizedBox<Rgb565>,
            Text<Gray4TextStyle>,
        )>,
    >,
}

impl AmountPage {
    pub fn new(index: usize, amount_sats: u64) -> Self {
        let title = Text::new(
            format!("Send Amount #{}", index + 1),
            Gray4TextStyle::new(FONT_PAGE_HEADER, PALETTE.text_secondary),
        );

        let spacer = SizedBox::<Rgb565>::new(Size::new(1, 10)); // 10px height spacing

        let amount_display = BitcoinAmountDisplay::new(amount_sats);

        let btc_spacer = SizedBox::<Rgb565>::new(Size::new(1, 10)); // 10px spacing before BTC

        let btc_text = Text::new(
            "BTC".to_string(),
            Gray4TextStyle::new(FONT_PAGE_HEADER, PALETTE.text_secondary),
        );

        let column = Column::new((title, spacer, amount_display, btc_spacer, btc_text))
            .with_main_axis_alignment(MainAxisAlignment::Center)
            .with_cross_axis_alignment(CrossAxisAlignment::Center);

        Self {
            center: Center::new(column),
        }
    }
}

// Trait implementations are now generated by the derive macro

/// Page widget for displaying recipient address
#[derive(frostsnap_macros::Widget)]
pub struct AddressPage {
    #[widget_delegate]
    center: Center<Padding<Column<(Text<Gray4TextStyle>, SizedBox<Rgb565>, AddressDisplay)>>>,
}

impl AddressPage {
    fn new_with_seed(index: usize, address: &bitcoin::Address, rand_seed: u32) -> Self {
        let title = Text::new(
            format!("To Address #{}", index + 1),
            Gray4TextStyle::new(FONT_PAGE_HEADER, PALETTE.text_secondary),
        );

        let spacer = SizedBox::<Rgb565>::new(Size::new(1, 10)); // 10px height spacing

        // Use our AddressDisplay widget which handles all address types
        // For P2TR addresses, use random seed for chunk highlighting (anti-address-poisoning)
        // Mix the seed with the index to get unique highlighting per address
        let mixed_seed = rand_seed.wrapping_add((index as u32).wrapping_mul(0x9e3779b9));
        let address_display = AddressDisplay::new_with_seed(address.clone(), mixed_seed);

        let column = Column::new((title, spacer, address_display))
            .with_main_axis_alignment(MainAxisAlignment::Start);
        let padded = Padding::only(column).bottom(40).build();

        Self {
            center: Center::new(padded),
        }
    }
}

// Trait implementations are now generated by the derive macro

/// Page widget for displaying network fee
#[derive(frostsnap_macros::Widget)]
pub struct FeePage {
    #[widget_delegate]
    center: Center<
        Column<(
            Text<Gray4TextStyle>,
            SizedBox<Rgb565>,
            BitcoinAmountDisplay,
            SizedBox<Rgb565>,
            Text<Gray4TextStyle>,
        )>,
    >,
}

impl FeePage {
    fn new(fee_sats: u64, fee_rate_sats_per_vbyte: Option<f64>) -> Self {
        let title = Text::new(
            "Network Fee".to_string(),
            Gray4TextStyle::new(FONT_PAGE_HEADER, PALETTE.text_secondary),
        );

        let spacer = SizedBox::<Rgb565>::new(Size::new(1, 10)); // 10px height spacing

        let fee_amount = BitcoinAmountDisplay::new(fee_sats);

        let btc_spacer = SizedBox::<Rgb565>::new(Size::new(1, 10)); // 10px spacing before fee rate

        // Display fee rate with 1 decimal place if available, otherwise show "BTC"
        let fee_rate_text = if let Some(rate) = fee_rate_sats_per_vbyte {
            Text::new(
                format!("{:.1} sats/vB", rate),
                Gray4TextStyle::new(FONT_PAGE_HEADER, PALETTE.text_secondary),
            )
        } else {
            Text::new(
                "BTC".to_string(),
                Gray4TextStyle::new(FONT_PAGE_HEADER, PALETTE.text_secondary),
            )
        };

        let column = Column::new((title, spacer, fee_amount, btc_spacer, fee_rate_text))
            .with_main_axis_alignment(MainAxisAlignment::Center)
            .with_cross_axis_alignment(CrossAxisAlignment::Center);

        Self {
            center: Center::new(column),
        }
    }
}

// Trait implementations are now generated by the derive macro

/// Page widget for high fee warning
#[derive(frostsnap_macros::Widget)]
pub struct WarningPage {
    #[widget_delegate]
    center: Center<
        Column<(
            Row<(
                Text<Gray4TextStyle>,
                SizedBox<Rgb565>,
                Column<(SizedBox<Rgb565>, Text<Gray4TextStyle>)>,
            )>,
            SizedBox<Rgb565>,
            Text<Gray4TextStyle>,
            SizedBox<Rgb565>,
            Column<(Text<Gray4TextStyle>, Text<Gray4TextStyle>)>,
        )>,
    >,
}

impl WarningPage {
    fn new(fee_sats: u64, _total_sent: u64) -> Self {
        // Use the warning icon as a Gray4 font glyph
        let warning_icon = Text::new(
            "âš ".to_string(),
            Gray4TextStyle::new(&WARNING_ICON, PALETTE.warning),
        );

        let icon_spacer = SizedBox::<Rgb565>::new(Size::new(5, 1)); // 5px horizontal spacing

        let caution_text = Text::new(
            "Caution".to_string(),
            Gray4TextStyle::new(FONT_CAUTION_NOTE, PALETTE.warning),
        );

        // Add a small spacer above the text to compensate for lack of descenders
        let text_top_spacer = SizedBox::<Rgb565>::new(Size::new(1, 5)); // 5px adjustment
        let text_with_spacer = Column::new((text_top_spacer, caution_text));

        // Put icon, spacer, and text column on same row
        let caution_row = Row::new((warning_icon, icon_spacer, text_with_spacer))
            .with_main_axis_alignment(MainAxisAlignment::Center);

        let spacer1 = SizedBox::<Rgb565>::new(Size::new(1, 10)); // Space after caution row

        // Title in white
        let title_text = Text::new(
            "High Fee".to_string(),
            Gray4TextStyle::new(FONT_CAUTION_TITLE, PALETTE.on_background),
        );

        let spacer2 = SizedBox::<Rgb565>::new(Size::new(1, 10)); // Space after title

        // Warning message in grey
        // Create specific warning text based on fee type
        let (line1, line2) = if fee_sats > HIGH_FEE_ABSOLUTE_THRESHOLD_SATS {
            ("Fee is greater".to_string(), "than 0.001 BTC".to_string())
        } else {
            (
                "Fee exceeds 5% of the".to_string(),
                "amount being sent".to_string(),
            )
        };

        let warning_line1 = Text::new(
            line1,
            Gray4TextStyle::new(FONT_CAUTION_TEXT, PALETTE.text_secondary),
        );

        let warning_line2 = Text::new(
            line2,
            Gray4TextStyle::new(FONT_CAUTION_TEXT, PALETTE.text_secondary),
        );

        let warning_text = Column::new((warning_line1, warning_line2))
            .with_cross_axis_alignment(CrossAxisAlignment::Center);

        let column = Column::new((caution_row, spacer1, title_text, spacer2, warning_text))
            .with_main_axis_alignment(MainAxisAlignment::Center)
            .with_cross_axis_alignment(CrossAxisAlignment::Center);

        Self {
            center: Center::new(column),
        }
    }
}

// Trait implementations are now generated by the derive macro

/// Confirmation page with HoldToConfirm
pub struct ConfirmationPage {
    hold_confirm: HoldToConfirm<
        Column<(
            SizedBox<Rgb565>,
            Text<Gray4TextStyle>,
            SizedBox<Rgb565>,
            Column<(Text<Gray4TextStyle>, Text<Gray4TextStyle>)>,
            SizedBox<Rgb565>,
        )>,
    >,
}

impl ConfirmationPage {
    fn new() -> Self {
        // Add more breathing room with larger spacers
        let spacer1 = SizedBox::<Rgb565>::new(Size::new(1, 40)); // Space before Hold to Sign

        let sign_text = Text::new(
            "Hold to Sign".to_string(),
            Gray4TextStyle::new(FONT_CONFIRM_TITLE, PALETTE.on_background),
        );

        let spacer2 = SizedBox::<Rgb565>::new(Size::new(1, 15)); // Space between texts

        // Split across two lines
        let press_line1 = Text::new(
            "Press and hold".to_string(),
            Gray4TextStyle::new(FONT_CONFIRM_TEXT, PALETTE.text_secondary),
        );
        let press_line2 = Text::new(
            "for 3 seconds".to_string(),
            Gray4TextStyle::new(FONT_CONFIRM_TEXT, PALETTE.text_secondary),
        );
        let press_text = Column::new((press_line1, press_line2));

        let spacer3 = SizedBox::<Rgb565>::new(Size::new(1, 40)); // Space after text

        let confirm_content = Column::new((spacer1, sign_text, spacer2, press_text, spacer3))
            .with_main_axis_alignment(MainAxisAlignment::Center)
            .with_cross_axis_alignment(CrossAxisAlignment::Center);

        let hold_confirm =
            HoldToConfirm::new(HOLD_TO_SIGN_TIME_MS, confirm_content).with_faded_out_button();

        Self { hold_confirm }
    }

    pub fn is_confirmed(&self) -> bool {
        self.hold_confirm.is_completed()
    }
}

impl DynWidget for ConfirmationPage {
    fn set_constraints(&mut self, max_size: Size) {
        self.hold_confirm.set_constraints(max_size);
    }

    fn sizing(&self) -> crate::Sizing {
        self.hold_confirm.sizing()
    }

    fn handle_touch(
        &mut self,
        point: Point,
        current_time: Instant,
        is_release: bool,
    ) -> Option<crate::KeyTouch> {
        self.hold_confirm
            .handle_touch(point, current_time, is_release)
    }

    fn handle_vertical_drag(&mut self, prev_y: Option<u32>, new_y: u32, is_release: bool) {
        self.hold_confirm
            .handle_vertical_drag(prev_y, new_y, is_release);
    }

    fn force_full_redraw(&mut self) {
        self.hold_confirm.force_full_redraw();
    }
}

impl Widget for ConfirmationPage {
    type Color = Rgb565;

    fn draw<D>(
        &mut self,
        target: &mut SuperDrawTarget<D, Self::Color>,
        current_time: Instant,
    ) -> Result<(), D::Error>
    where
        D: DrawTarget<Color = Self::Color>,
    {
        self.hold_confirm.draw(target, current_time)
    }
}

/// Type alias for the different pages that can be displayed
type SignPromptPage = AnyOf<(
    AmountPage,
    AddressPage,
    FeePage,
    WarningPage,
    ConfirmationPage,
)>;

impl SignPromptPageList {
    fn new_with_seed(prompt: PromptSignBitcoinTx, rand_seed: u32) -> Self {
        let num_recipients = prompt.foreign_recipients.len();
        let has_warning = Self::has_high_fee(&prompt);

        // Each recipient has 2 pages (amount, address), plus fee page, plus optional warning, plus confirmation
        let total_pages = num_recipients * 2 + 1 + if has_warning { 1 } else { 0 } + 1;

        Self {
            prompt,
            total_pages,
            rand_seed,
        }
    }

    /// Check if the transaction has high fees that warrant a warning
    fn has_high_fee(prompt: &PromptSignBitcoinTx) -> bool {
        let fee_sats = prompt.fee.to_sat();

        // High fee if > 0.001 BTC
        if fee_sats > HIGH_FEE_ABSOLUTE_THRESHOLD_SATS {
            return true;
        }

        // High fee if > percentage threshold of total amount being sent
        let total_sent: u64 = prompt
            .foreign_recipients
            .iter()
            .map(|(_, amount)| amount.to_sat())
            .sum();
        if total_sent > 0 && fee_sats > total_sent * HIGH_FEE_PERCENTAGE_THRESHOLD / 100 {
            return true;
        }

        false
    }
}

impl WidgetList<SignPromptPage> for SignPromptPageList {
    fn len(&self) -> usize {
        self.total_pages
    }

    fn get(&self, index: usize) -> Option<SignPromptPage> {
        if index >= self.total_pages {
            return None;
        }

        let num_recipients = self.prompt.foreign_recipients.len();
        let recipient_pages = num_recipients * 2;
        let has_warning = Self::has_high_fee(&self.prompt);

        let page = if index < recipient_pages {
            // It's either an amount or address page for a recipient
            let recipient_idx = index / 2;
            let is_amount = index.is_multiple_of(2);

            if is_amount {
                // Amount page
                let (_, amount) = &self.prompt.foreign_recipients[recipient_idx];
                SignPromptPage::new(AmountPage::new(recipient_idx, amount.to_sat()))
            } else {
                // Address page
                let (address, _) = &self.prompt.foreign_recipients[recipient_idx];
                SignPromptPage::new(AddressPage::new_with_seed(
                    recipient_idx,
                    address,
                    self.rand_seed,
                ))
            }
        } else if has_warning && index == recipient_pages {
            // Warning page (if applicable) - shown before fee page
            let total_sent: u64 = self
                .prompt
                .foreign_recipients
                .iter()
                .map(|(_, amount)| amount.to_sat())
                .sum();
            SignPromptPage::new(WarningPage::new(self.prompt.fee.to_sat(), total_sent))
        } else if (has_warning && index == recipient_pages + 1)
            || (!has_warning && index == recipient_pages)
        {
            // Fee page - comes after warning if warning exists, otherwise right after recipients
            SignPromptPage::new(FeePage::new(
                self.prompt.fee.to_sat(),
                self.prompt.fee_rate_sats_per_vbyte,
            ))
        } else {
            // Confirmation page (last page)
            SignPromptPage::new(ConfirmationPage::new())
        };

        Some(page)
    }

    fn can_go_prev(&self, from_index: usize, current_widget: &SignPromptPage) -> bool {
        // If we're on the last page (confirmation screen)
        if from_index == self.total_pages - 1 {
            // Check if the confirmation screen has been confirmed
            if let Some(confirmation_page) = current_widget.downcast_ref::<ConfirmationPage>() {
                // Don't allow going back if confirmed
                return !confirmation_page.is_confirmed();
            }
        }
        true // Allow navigation for all other cases
    }
}

/// High-level widget that manages the complete sign prompt flow using PageSlider
#[derive(frostsnap_macros::Widget)]
pub struct SignTxPrompt {
    #[widget_delegate]
    page_slider: PageSlider<SignPromptPageList, SignPromptPage>,
}

impl SignTxPrompt {
    pub fn new(prompt: PromptSignBitcoinTx) -> Self {
        Self::new_with_seed(prompt, 0)
    }

    pub fn new_with_seed(prompt: PromptSignBitcoinTx, rand_seed: u32) -> Self {
        let page_list = SignPromptPageList::new_with_seed(prompt, rand_seed);
        let page_slider = PageSlider::new(page_list)
            .with_on_page_ready(|page| {
                // Try to downcast to ConfirmationPage
                if let Some(confirmation_page) = page.downcast_mut::<ConfirmationPage>() {
                    // Fade in the button when the confirmation page is ready
                    confirmation_page.hold_confirm.fade_in_button();
                }
            })
            .with_swipe_up_chevron();

        Self { page_slider }
    }

    /// Check if the transaction has been confirmed
    pub fn is_confirmed(&mut self) -> bool {
        // Check if we're on the last page
        if self.page_slider.current_index() == self.page_slider.total_pages() - 1 {
            let current_widget = self.page_slider.current_widget();
            if let Some(confirmation_page) = current_widget.downcast_ref::<ConfirmationPage>() {
                return confirmation_page.is_confirmed();
            }
        }
        false
    }
}
