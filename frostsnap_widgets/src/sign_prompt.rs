use crate::DefaultTextStyle;
use crate::{
    address_display::AddressDisplay, any_of::AnyOf, bitcoin_amount_display::BitcoinAmountDisplay,
    icons::IconWidget, page_slider::PageSlider, palette::PALETTE, prelude::*,
    widget_list::WidgetList, HoldToConfirm, HOLD_TO_CONFIRM_TIME_MS,
};
use alloc::{format, string::ToString};
use embedded_graphics::{
    draw_target::DrawTarget,
    geometry::{Point, Size},
    pixelcolor::Rgb565,
};
use frostsnap_core::bitcoin_transaction::PromptSignBitcoinTx;

/// Widget list that generates sign prompt pages
pub struct SignPromptPageList {
    prompt: PromptSignBitcoinTx,
    total_pages: usize,
}

/// Page widget for displaying amount to send
#[derive(frostsnap_macros::Widget)]
pub struct AmountPage {
    #[widget_delegate]
    center: Center<
        Column<(
            Text,
            SizedBox<Rgb565>,
            BitcoinAmountDisplay,
            SizedBox<Rgb565>,
            Text,
        )>,
    >,
}

impl AmountPage {
    pub fn new(index: usize, amount_sats: u64) -> Self {
        let title = Text::new(
            format!("Send Amount #{}", index + 1),
            DefaultTextStyle::new(crate::FONT_MED, PALETTE.text_secondary),
        );

        let spacer = SizedBox::<Rgb565>::new(Size::new(1, 15)); // 15px height spacing

        let amount_display = BitcoinAmountDisplay::new(amount_sats);

        let btc_spacer = SizedBox::<Rgb565>::new(Size::new(1, 10)); // 10px spacing before BTC

        let btc_text = Text::new(
            "BTC".to_string(),
            DefaultTextStyle::new(crate::FONT_MED, PALETTE.text_secondary),
        );

        let column = Column::new((title, spacer, amount_display, btc_spacer, btc_text))
            .with_main_axis_alignment(MainAxisAlignment::Center)
            .with_cross_axis_alignment(CrossAxisAlignment::Center);

        Self {
            center: Center::new(column),
        }
    }
}

// Trait implementations are now generated by the derive macro

/// Page widget for displaying recipient address
#[derive(frostsnap_macros::Widget)]
pub struct AddressPage {
    #[widget_delegate]
    center: Center<Padding<Column<(Text, AddressDisplay)>>>,
}

impl AddressPage {
    fn new(index: usize, address: &bitcoin::Address) -> Self {
        let title = Text::new(
            format!("Address #{}", index + 1),
            DefaultTextStyle::new(crate::FONT_MED, PALETTE.text_secondary),
        );

        // Use our AddressDisplay widget which handles all address types
        let address_display = AddressDisplay::new(address.clone());

        let column = Column::new((title, address_display))
            .with_main_axis_alignment(MainAxisAlignment::SpaceAround);
        let padded = Padding::only(column).top(8).bottom(40).build();

        Self {
            center: Center::new(padded),
        }
    }
}

// Trait implementations are now generated by the derive macro

/// Page widget for displaying network fee
#[derive(frostsnap_macros::Widget)]
pub struct FeePage {
    #[widget_delegate]
    center: Center<Column<(Text, BitcoinAmountDisplay, Text)>>,
}

impl FeePage {
    fn new(fee_sats: u64) -> Self {
        let title = Text::new(
            "Network Fee".to_string(),
            DefaultTextStyle::new(crate::FONT_MED, PALETTE.text_secondary),
        );

        let fee_amount = BitcoinAmountDisplay::new(fee_sats);

        let fee_sats_text = Text::new(
            format!("{} sats", fee_sats),
            DefaultTextStyle::new(crate::FONT_SMALL, PALETTE.text_secondary),
        );

        let column = Column::new((title, fee_amount, fee_sats_text))
            .with_main_axis_alignment(MainAxisAlignment::SpaceEvenly);

        Self {
            center: Center::new(column),
        }
    }
}

// Trait implementations are now generated by the derive macro

/// Page widget for high fee warning
#[derive(frostsnap_macros::Widget)]
pub struct WarningPage {
    #[widget_delegate]
    center: Center<
        Column<(
            IconWidget<
                embedded_iconoir::Icon<
                    Rgb565,
                    embedded_iconoir::icons::size48px::actions::WarningTriangle,
                >,
            >,
            Text,
            Text,
        )>,
    >,
}

impl WarningPage {
    fn new(fee_sats: u64, _total_sent: u64) -> Self {
        use embedded_iconoir::prelude::*;

        let warning_icon = IconWidget::new(
            embedded_iconoir::icons::size48px::actions::WarningTriangle::new(PALETTE.error),
        );

        let caution_text = Text::new(
            "Caution".to_string(),
            DefaultTextStyle::new(crate::FONT_LARGE, PALETTE.error),
        );

        let warning_msg = if fee_sats > 100_000 {
            "Fee exceeds\n0.001 BTC"
        } else {
            "Fee exceeds\n5% of amount"
        };

        let warning_text = Text::new(
            warning_msg.to_string(),
            DefaultTextStyle::new(crate::FONT_MED, PALETTE.on_surface),
        );

        let column = Column::new((warning_icon, caution_text, warning_text))
            .with_main_axis_alignment(MainAxisAlignment::Center);

        Self {
            center: Center::new(column),
        }
    }
}

// Trait implementations are now generated by the derive macro

/// Confirmation page with HoldToConfirm
pub struct ConfirmationPage {
    hold_confirm: HoldToConfirm<Column<(Text, Text, BitcoinAmountDisplay, Text)>>,
}

impl ConfirmationPage {
    fn new(total_sats: u64) -> Self {
        let sign_text = Text::new(
            "Sign transaction?",
            DefaultTextStyle::new(crate::FONT_MED, PALETTE.on_background),
        );
        let sending_text = Text::new(
            "sending",
            DefaultTextStyle::new(crate::FONT_SMALL, PALETTE.text_secondary),
        );
        let amount_display = BitcoinAmountDisplay::new(total_sats);
        let btc_text = Text::new(
            "BTC",
            DefaultTextStyle::new(crate::FONT_SMALL, PALETTE.text_secondary),
        );

        let confirm_content = Column::new((sign_text, sending_text, amount_display, btc_text))
            .with_main_axis_alignment(MainAxisAlignment::Center);

        let hold_confirm =
            HoldToConfirm::new(HOLD_TO_CONFIRM_TIME_MS, confirm_content).with_faded_out_button();

        Self { hold_confirm }
    }

    pub fn is_confirmed(&self) -> bool {
        self.hold_confirm.is_completed()
    }
}

impl DynWidget for ConfirmationPage {
    fn set_constraints(&mut self, max_size: Size) {
        self.hold_confirm.set_constraints(max_size);
    }

    fn sizing(&self) -> crate::Sizing {
        self.hold_confirm.sizing()
    }

    fn handle_touch(
        &mut self,
        point: Point,
        current_time: Instant,
        is_release: bool,
    ) -> Option<crate::KeyTouch> {
        self.hold_confirm
            .handle_touch(point, current_time, is_release)
    }

    fn handle_vertical_drag(&mut self, prev_y: Option<u32>, new_y: u32, is_release: bool) {
        self.hold_confirm
            .handle_vertical_drag(prev_y, new_y, is_release);
    }

    fn force_full_redraw(&mut self) {
        self.hold_confirm.force_full_redraw();
    }
}

impl Widget for ConfirmationPage {
    type Color = Rgb565;

    fn draw<D>(
        &mut self,
        target: &mut SuperDrawTarget<D, Self::Color>,
        current_time: Instant,
    ) -> Result<(), D::Error>
    where
        D: DrawTarget<Color = Self::Color>,
    {
        self.hold_confirm.draw(target, current_time)
    }
}

/// Type alias for the different pages that can be displayed
type SignPromptPage = AnyOf<(
    AmountPage,
    AddressPage,
    FeePage,
    WarningPage,
    ConfirmationPage,
)>;

impl SignPromptPageList {
    fn new(prompt: PromptSignBitcoinTx) -> Self {
        let num_recipients = prompt.foreign_recipients.len();
        let has_warning = Self::has_high_fee(&prompt);

        // Each recipient has 2 pages (amount, address), plus fee page, plus optional warning, plus confirmation
        let total_pages = num_recipients * 2 + 1 + if has_warning { 1 } else { 0 } + 1;

        Self {
            prompt,
            total_pages,
        }
    }

    /// Check if the transaction has high fees that warrant a warning
    fn has_high_fee(prompt: &PromptSignBitcoinTx) -> bool {
        let fee_sats = prompt.fee.to_sat();

        // High fee if > 0.001 BTC (100,000 sats)
        if fee_sats > 100_000 {
            return true;
        }

        // High fee if > 5% of total amount being sent
        let total_sent: u64 = prompt
            .foreign_recipients
            .iter()
            .map(|(_, amount)| amount.to_sat())
            .sum();
        if total_sent > 0 && fee_sats > total_sent / 20 {
            return true;
        }

        false
    }
}

impl WidgetList<SignPromptPage> for SignPromptPageList {
    fn len(&self) -> usize {
        self.total_pages
    }

    fn get(&self, index: usize) -> Option<SignPromptPage> {
        if index >= self.total_pages {
            return None;
        }

        let num_recipients = self.prompt.foreign_recipients.len();
        let recipient_pages = num_recipients * 2;
        let has_warning = Self::has_high_fee(&self.prompt);

        let page = if index < recipient_pages {
            // It's either an amount or address page for a recipient
            let recipient_idx = index / 2;
            let is_amount = index.is_multiple_of(2);

            if is_amount {
                // Amount page
                let (_, amount) = &self.prompt.foreign_recipients[recipient_idx];
                SignPromptPage::new(AmountPage::new(recipient_idx, amount.to_sat()))
            } else {
                // Address page
                let (address, _) = &self.prompt.foreign_recipients[recipient_idx];
                SignPromptPage::new(AddressPage::new(recipient_idx, address))
            }
        } else if index == recipient_pages {
            // Fee page
            SignPromptPage::new(FeePage::new(self.prompt.fee.to_sat()))
        } else if has_warning && index == recipient_pages + 1 {
            // Warning page (if applicable)
            let total_sent: u64 = self
                .prompt
                .foreign_recipients
                .iter()
                .map(|(_, amount)| amount.to_sat())
                .sum();
            SignPromptPage::new(WarningPage::new(self.prompt.fee.to_sat(), total_sent))
        } else {
            // Confirmation page (last page)
            let total_sent: u64 = self
                .prompt
                .foreign_recipients
                .iter()
                .map(|(_, amount)| amount.to_sat())
                .sum();
            SignPromptPage::new(ConfirmationPage::new(total_sent))
        };

        Some(page)
    }

    fn can_go_prev(&self, from_index: usize, current_widget: &SignPromptPage) -> bool {
        // If we're on the last page (confirmation screen)
        if from_index == self.total_pages - 1 {
            // Check if the confirmation screen has been confirmed
            if let Some(confirmation_page) = current_widget.downcast_ref::<ConfirmationPage>() {
                // Don't allow going back if confirmed
                return !confirmation_page.is_confirmed();
            }
        }
        true // Allow navigation for all other cases
    }
}

/// High-level widget that manages the complete sign prompt flow using PageSlider
#[derive(frostsnap_macros::Widget)]
pub struct SignTxPrompt {
    #[widget_delegate]
    page_slider: PageSlider<SignPromptPageList, SignPromptPage>,
}

impl SignTxPrompt {
    pub fn new(prompt: PromptSignBitcoinTx) -> Self {
        let page_list = SignPromptPageList::new(prompt);
        let page_slider = PageSlider::new(page_list, 40)
            .with_on_page_ready(|page| {
                // Try to downcast to ConfirmationPage
                if let Some(confirmation_page) = page.downcast_mut::<ConfirmationPage>() {
                    // Fade in the button when the confirmation page is ready
                    confirmation_page.hold_confirm.fade_in_button();
                }
            })
            .with_swipe_up_chevron();

        Self { page_slider }
    }

    /// Check if the transaction has been confirmed
    pub fn is_confirmed(&mut self) -> bool {
        // Check if we're on the last page
        if self.page_slider.current_index() == self.page_slider.total_pages() - 1 {
            let current_widget = self.page_slider.current_widget();
            if let Some(confirmation_page) = current_widget.downcast_ref::<ConfirmationPage>() {
                return confirmation_page.is_confirmed();
            }
        }
        false
    }
}
