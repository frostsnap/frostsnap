use crate::{
    fonts::Gray4Font, palette::PALETTE, text::Text, Column, DefaultTextStyle, MainAxisAlignment,
    Row, FONT_HUGE_MONO,
};
use alloc::{boxed::Box, string::String, vec::Vec};

// Font for displaying addresses - uses monospace for better readability
const ADDRESS_FONT: &Gray4Font = FONT_HUGE_MONO;

// Type alias for a row with three text chunks
type AddressRow = Row<(Text, Text, Text)>;

/// A widget for displaying P2TR (Taproot) addresses in a specific format:
/// - 1 row with the first chunk (grayed out)
/// - 5 rows with 3 chunks each (4 chars per chunk)
/// - Total: 62 characters displayed as 16 chunks
#[derive(frostsnap_macros::Widget)]
pub struct P2trAddressDisplay {
    #[widget_delegate]
    column: Column<
        Box<(
            Row<(Text,)>,
            AddressRow,
            AddressRow,
            AddressRow,
            AddressRow,
            AddressRow,
        )>,
    >,
}

impl P2trAddressDisplay {
    pub fn new(address: &str) -> Self {
        // P2TR addresses are always 62 characters (ASCII)
        // Split into chunks of 4 characters, padding with spaces as needed
        let chunks: Vec<String> = (0..address.len())
            .step_by(4)
            .map(|start| {
                let end = (start + 4).min(address.len());
                let chunk = &address[start..end];
                // Pad to 4 characters with spaces
                format!("{:4}", chunk)
            })
            .collect();

        // Use monospace font for the address text
        let text_style = DefaultTextStyle::new(ADDRESS_FONT, PALETTE.on_surface);

        // First chunk on its own row (grayed out)
        let type_indicator = Row::new((Text::new(chunks[0].clone(), text_style.clone()),));

        // Create an iterator that produces rows of 3 chunks each
        let mut row_iter = chunks[1..].chunks(3).map(|row_chunks| {
            Row::new((
                Text::new(row_chunks[0].clone(), text_style.clone()),
                Text::new(row_chunks[1].clone(), text_style.clone()),
                Text::new(row_chunks[2].clone(), text_style.clone()),
            ))
            .with_main_axis_alignment(MainAxisAlignment::SpaceAround)
        });

        // Create column with all rows
        let column = Column::new(Box::new((
            type_indicator,
            row_iter.next().unwrap(),
            row_iter.next().unwrap(),
            row_iter.next().unwrap(),
            row_iter.next().unwrap(),
            row_iter.next().unwrap(),
        )))
        .with_main_axis_alignment(MainAxisAlignment::SpaceEvenly);

        Self { column }
    }
}

// All trait implementations are now generated by the derive macro
