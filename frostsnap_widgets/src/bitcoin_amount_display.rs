use crate::DefaultTextStyle;
use crate::{palette::PALETTE, prelude::*, rat::FatRat};
use alloc::string::ToString;
use embedded_graphics::{geometry::Size, pixelcolor::Rgb565};

// Type alias to reduce complexity
type BitcoinAmountRow = Row<(
    Text,             // Whole part + decimal point
    Text,             // First decimal digit
    Text,             // Second decimal digit
    SizedBox<Rgb565>, // Half-width space
    Text,             // Third decimal digit
    Text,             // Fourth decimal digit
    Text,             // Fifth decimal digit
    SizedBox<Rgb565>, // Half-width space
    Text,             // Sixth decimal digit
    Text,             // Seventh decimal digit
    Text,             // Eighth decimal digit
)>;

/// A widget that displays a Bitcoin amount with proper formatting and coloring
/// Displays in format: X.XX XXX XXX with half-width spaces between segments
#[derive(frostsnap_macros::Widget)]
pub struct BitcoinAmountDisplay {
    /// The row containing all elements - delegated by the derive macro
    #[widget_delegate]
    row: BitcoinAmountRow,
    /// Amount in satoshis (for reference)
    satoshis: u64,
}

impl BitcoinAmountDisplay {
    pub fn new(satoshis: u64) -> Self {
        let btc = FatRat::from_ratio(satoshis, 100_000_000);
        let amount_str = format!("{}.", btc.whole_part());
        let mut color = PALETTE.text_disabled;
        if btc.whole_part() > 0 {
            color = PALETTE.primary;
        }
        let whole_text = Text::new(amount_str, DefaultTextStyle::new(crate::FONT_LARGE, color));

        // Get decimal digits iterator (take only 8 for Bitcoin)
        let mut after_decimal = btc.decimal_digits().take(8).map(|digit| {
            if digit > 0 {
                color = PALETTE.primary;
            }
            Text::new(
                digit.to_string(),
                DefaultTextStyle::new(crate::FONT_LARGE, color),
            )
        });

        // Half-width spacers (approximately half the width of a digit)
        let spacer1 = SizedBox::<Rgb565>::new(Size::new(4, 1));
        let spacer2 = SizedBox::<Rgb565>::new(Size::new(4, 1));

        // Create row with all elements
        let row = Row::new((
            whole_text,
            after_decimal.next().unwrap(),
            after_decimal.next().unwrap(),
            spacer1,
            after_decimal.next().unwrap(),
            after_decimal.next().unwrap(),
            after_decimal.next().unwrap(),
            spacer2,
            after_decimal.next().unwrap(),
            after_decimal.next().unwrap(),
            after_decimal.next().unwrap(),
        ));

        Self { row, satoshis }
    }

    pub fn satoshis(&self) -> u64 {
        self.satoshis
    }
}

// All trait implementations are now generated by the derive macro
