use crate::{
    fonts::{Gray4TextStyle, NOTO_SANS_MONO_28_BOLD},
    palette::PALETTE,
    prelude::*,
    rat::FatRat,
};
use alloc::string::ToString;
use embedded_graphics::{geometry::Size, pixelcolor::Rgb565};

// Font constant for Bitcoin amounts
const FONT_BITCOIN_AMOUNT: &crate::fonts::Gray4Font = &NOTO_SANS_MONO_28_BOLD;

// Type alias to reduce complexity
type BitcoinAmountRow = Row<(
    Text<Gray4TextStyle<'static>>, // Whole part + decimal point
    Text<Gray4TextStyle<'static>>, // First decimal digit
    Text<Gray4TextStyle<'static>>, // Second decimal digit
    SizedBox<Rgb565>,              // Half-width space
    Text<Gray4TextStyle<'static>>, // Third decimal digit
    Text<Gray4TextStyle<'static>>, // Fourth decimal digit
    Text<Gray4TextStyle<'static>>, // Fifth decimal digit
    SizedBox<Rgb565>,              // Half-width space
    Text<Gray4TextStyle<'static>>, // Sixth decimal digit
    Text<Gray4TextStyle<'static>>, // Seventh decimal digit
    Text<Gray4TextStyle<'static>>, // Eighth decimal digit
)>;

/// A widget that displays a Bitcoin amount with proper formatting and coloring
/// Displays in format: X.XX XXX XXX with half-width spaces between segments
#[derive(frostsnap_macros::Widget)]
pub struct BitcoinAmountDisplay {
    /// The row containing all elements - delegated by the derive macro
    #[widget_delegate]
    row: BitcoinAmountRow,
    /// Amount in satoshis (for reference)
    satoshis: u64,
}

impl BitcoinAmountDisplay {
    pub fn new(satoshis: u64) -> Self {
        let btc = FatRat::from_ratio(satoshis, 100_000_000);
        let amount_str = format!("{}.", btc.whole_part());
        let mut color = PALETTE.text_disabled;
        if btc.whole_part() > 0 {
            color = PALETTE.primary;
        }
        let whole_text = Text::new(amount_str, Gray4TextStyle::new(FONT_BITCOIN_AMOUNT, color));

        // Get decimal digits iterator (take only 8 for Bitcoin)
        let mut after_decimal = btc.decimal_digits().take(8).map(|digit| {
            if digit > 0 {
                color = PALETTE.primary;
            }
            Text::new(
                digit.to_string(),
                Gray4TextStyle::new(FONT_BITCOIN_AMOUNT, color),
            )
        });

        // Half-width spacers (approximately half the width of a digit)
        let spacer1 = SizedBox::<Rgb565>::new(Size::new(4, 1));
        let spacer2 = SizedBox::<Rgb565>::new(Size::new(4, 1));

        // Create row with all elements
        let row = Row::new((
            whole_text,
            after_decimal.next().unwrap(),
            after_decimal.next().unwrap(),
            spacer1,
            after_decimal.next().unwrap(),
            after_decimal.next().unwrap(),
            after_decimal.next().unwrap(),
            spacer2,
            after_decimal.next().unwrap(),
            after_decimal.next().unwrap(),
            after_decimal.next().unwrap(),
        ));

        Self { row, satoshis }
    }

    pub fn satoshis(&self) -> u64 {
        self.satoshis
    }
}

// All trait implementations are now generated by the derive macro
