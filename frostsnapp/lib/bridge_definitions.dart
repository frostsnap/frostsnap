// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.82.6.
// ignore_for_file: non_constant_identifier_names, unused_element, duplicate_ignore, directives_ordering, curly_braces_in_flow_control_structures, unnecessary_lambdas, slash_for_doc_comments, prefer_const_literals_to_create_immutables, implicit_dynamic_list_literal, duplicate_import, unused_import, unnecessary_import, prefer_single_quotes, prefer_const_constructors, use_super_parameters, always_use_package_imports, annotate_overrides, invalid_use_of_protected_member, constant_identifier_names, invalid_use_of_internal_member, prefer_is_empty, unnecessary_const

import 'bridge_generated.io.dart'
    if (dart.library.html) 'bridge_generated.web.dart';
import 'dart:convert';
import 'dart:async';
import 'package:meta/meta.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';
import 'package:uuid/uuid.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'package:collection/collection.dart';

part 'bridge_definitions.freezed.dart';

abstract class Native {
  Stream<PortEvent> subPortEvents({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSubPortEventsConstMeta;

  Stream<DeviceListUpdate> subDeviceEvents({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSubDeviceEventsConstMeta;

  Stream<KeyState> subKeyEvents({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSubKeyEventsConstMeta;

  Future<void> emitKeyEvent({required KeyState event, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kEmitKeyEventConstMeta;

  Future<void> turnStderrLoggingOn({required Level level, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTurnStderrLoggingOnConstMeta;

  Future<void> turnLogcatLoggingOn({required Level level, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTurnLogcatLoggingOnConstMeta;

  Device? deviceAtIndex({required int index, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDeviceAtIndexConstMeta;

  DeviceListState deviceListState({dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDeviceListStateConstMeta;

  Device getDevice({required DeviceId id, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetDeviceConstMeta;

  Future<(Coordinator, Wallet)> load({required String dbFile, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kLoadConstMeta;

  Future<(Coordinator, FfiSerial, Wallet)> loadHostHandlesSerial(
      {required String dbFile, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kLoadHostHandlesSerialConstMeta;

  Future<KeyId> echoKeyId({required KeyId keyId, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kEchoKeyIdConstMeta;

  String txidMethodTransaction({required Transaction that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTxidMethodTransactionConstMeta;

  int thresholdMethodFrostKey({required FrostKey that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kThresholdMethodFrostKeyConstMeta;

  KeyId idMethodFrostKey({required FrostKey that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kIdMethodFrostKeyConstMeta;

  String nameMethodFrostKey({required FrostKey that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNameMethodFrostKeyConstMeta;

  List<Device> devicesMethodFrostKey({required FrostKey that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDevicesMethodFrostKeyConstMeta;

  Future<void> satisfyMethodPortOpen(
      {required PortOpen that, String? err, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSatisfyMethodPortOpenConstMeta;

  Future<void> satisfyMethodPortRead(
      {required PortRead that,
      required Uint8List bytes,
      String? err,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSatisfyMethodPortReadConstMeta;

  Future<void> satisfyMethodPortWrite(
      {required PortWrite that, String? err, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSatisfyMethodPortWriteConstMeta;

  Future<void> satisfyMethodPortBytesToRead(
      {required PortBytesToRead that, required int bytesToRead, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSatisfyMethodPortBytesToReadConstMeta;

  bool isFinishedMethodSigningState({required SigningState that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kIsFinishedMethodSigningStateConstMeta;

  List<DeviceId> namedDevicesMethodDeviceListState(
      {required DeviceListState that, dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kNamedDevicesMethodDeviceListStateConstMeta;

  Future<void> setAvailablePortsMethodFfiSerial(
      {required FfiSerial that, required List<PortDesc> ports, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSetAvailablePortsMethodFfiSerialConstMeta;

  Future<void> startThreadMethodCoordinator(
      {required Coordinator that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kStartThreadMethodCoordinatorConstMeta;

  Future<void> updateNamePreviewMethodCoordinator(
      {required Coordinator that,
      required DeviceId id,
      required String name,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kUpdateNamePreviewMethodCoordinatorConstMeta;

  Future<void> finishNamingMethodCoordinator(
      {required Coordinator that,
      required DeviceId id,
      required String name,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kFinishNamingMethodCoordinatorConstMeta;

  Future<void> sendCancelMethodCoordinator(
      {required Coordinator that, required DeviceId id, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSendCancelMethodCoordinatorConstMeta;

  Future<void> cancelAllMethodCoordinator(
      {required Coordinator that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kCancelAllMethodCoordinatorConstMeta;

  KeyState keyStateMethodCoordinator({required Coordinator that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kKeyStateMethodCoordinatorConstMeta;

  FrostKey? getKeyMethodCoordinator(
      {required Coordinator that, required KeyId keyId, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetKeyMethodCoordinatorConstMeta;

  Stream<SigningState> startSigningMethodCoordinator(
      {required Coordinator that,
      required KeyId keyId,
      required List<DeviceId> devices,
      required String message,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kStartSigningMethodCoordinatorConstMeta;

  SigningState? getSigningStateMethodCoordinator(
      {required Coordinator that, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGetSigningStateMethodCoordinatorConstMeta;

  int noncesAvailableMethodCoordinator(
      {required Coordinator that, required DeviceId id, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNoncesAvailableMethodCoordinatorConstMeta;

  Stream<CoordinatorToUserKeyGenMessage> generateNewKeyMethodCoordinator(
      {required Coordinator that,
      required int threshold,
      required List<DeviceId> devices,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kGenerateNewKeyMethodCoordinatorConstMeta;

  bool canRestoreSigningSessionMethodCoordinator(
      {required Coordinator that, required KeyId keyId, dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kCanRestoreSigningSessionMethodCoordinatorConstMeta;

  Stream<SigningState> tryRestoreSigningSessionMethodCoordinator(
      {required Coordinator that, required KeyId keyId, dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kTryRestoreSigningSessionMethodCoordinatorConstMeta;

  Stream<TxState> subTxStateMethodWallet(
      {required Wallet that, required KeyId keyId, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSubTxStateMethodWalletConstMeta;

  TxState txStateMethodWallet(
      {required Wallet that, required KeyId keyId, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kTxStateMethodWalletConstMeta;

  Stream<double> syncTxidsMethodWallet(
      {required Wallet that,
      required KeyId keyId,
      required List<String> txids,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncTxidsMethodWalletConstMeta;

  Stream<double> syncMethodWallet(
      {required Wallet that, required KeyId keyId, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSyncMethodWalletConstMeta;

  Future<Address> nextAddressMethodWallet(
      {required Wallet that, required KeyId keyId, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNextAddressMethodWalletConstMeta;

  List<Address> addressesStateMethodWallet(
      {required Wallet that, required KeyId keyId, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kAddressesStateMethodWalletConstMeta;

  DropFnType get dropOpaqueArcMutexVecPortDesc;
  ShareFnType get shareOpaqueArcMutexVecPortDesc;
  OpaqueTypeFinalizer get ArcMutexVecPortDescFinalizer;

  DropFnType get dropOpaqueChainSync;
  ShareFnType get shareOpaqueChainSync;
  OpaqueTypeFinalizer get ChainSyncFinalizer;

  DropFnType get dropOpaqueFfiCoordinator;
  ShareFnType get shareOpaqueFfiCoordinator;
  OpaqueTypeFinalizer get FfiCoordinatorFinalizer;

  DropFnType get dropOpaqueFrostsnapCoreCoordinatorFrostKeyState;
  ShareFnType get shareOpaqueFrostsnapCoreCoordinatorFrostKeyState;
  OpaqueTypeFinalizer get FrostsnapCoreCoordinatorFrostKeyStateFinalizer;

  DropFnType get dropOpaqueMutexBTreeMapKeyIdStreamSinkTxState;
  ShareFnType get shareOpaqueMutexBTreeMapKeyIdStreamSinkTxState;
  OpaqueTypeFinalizer get MutexBTreeMapKeyIdStreamSinkTxStateFinalizer;

  DropFnType get dropOpaqueMutexCrateWalletWallet;
  ShareFnType get shareOpaqueMutexCrateWalletWallet;
  OpaqueTypeFinalizer get MutexCrateWalletWalletFinalizer;

  DropFnType get dropOpaquePortBytesToReadSender;
  ShareFnType get shareOpaquePortBytesToReadSender;
  OpaqueTypeFinalizer get PortBytesToReadSenderFinalizer;

  DropFnType get dropOpaquePortOpenSender;
  ShareFnType get shareOpaquePortOpenSender;
  OpaqueTypeFinalizer get PortOpenSenderFinalizer;

  DropFnType get dropOpaquePortReadSender;
  ShareFnType get shareOpaquePortReadSender;
  OpaqueTypeFinalizer get PortReadSenderFinalizer;

  DropFnType get dropOpaquePortWriteSender;
  ShareFnType get shareOpaquePortWriteSender;
  OpaqueTypeFinalizer get PortWriteSenderFinalizer;

  DropFnType get dropOpaqueRTransaction;
  ShareFnType get shareOpaqueRTransaction;
  OpaqueTypeFinalizer get RTransactionFinalizer;
}

@sealed
class ArcMutexVecPortDesc extends FrbOpaque {
  final Native bridge;
  ArcMutexVecPortDesc.fromRaw(int ptr, int size, this.bridge)
      : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueArcMutexVecPortDesc;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueArcMutexVecPortDesc;

  @override
  OpaqueTypeFinalizer get staticFinalizer =>
      bridge.ArcMutexVecPortDescFinalizer;
}

@sealed
class ChainSync extends FrbOpaque {
  final Native bridge;
  ChainSync.fromRaw(int ptr, int size, this.bridge) : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueChainSync;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueChainSync;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.ChainSyncFinalizer;
}

@sealed
class FfiCoordinator extends FrbOpaque {
  final Native bridge;
  FfiCoordinator.fromRaw(int ptr, int size, this.bridge)
      : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueFfiCoordinator;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueFfiCoordinator;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.FfiCoordinatorFinalizer;
}

@sealed
class FrostsnapCoreCoordinatorFrostKeyState extends FrbOpaque {
  final Native bridge;
  FrostsnapCoreCoordinatorFrostKeyState.fromRaw(int ptr, int size, this.bridge)
      : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn =>
      bridge.dropOpaqueFrostsnapCoreCoordinatorFrostKeyState;

  @override
  ShareFnType get shareFn =>
      bridge.shareOpaqueFrostsnapCoreCoordinatorFrostKeyState;

  @override
  OpaqueTypeFinalizer get staticFinalizer =>
      bridge.FrostsnapCoreCoordinatorFrostKeyStateFinalizer;
}

@sealed
class MutexBTreeMapKeyIdStreamSinkTxState extends FrbOpaque {
  final Native bridge;
  MutexBTreeMapKeyIdStreamSinkTxState.fromRaw(int ptr, int size, this.bridge)
      : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueMutexBTreeMapKeyIdStreamSinkTxState;

  @override
  ShareFnType get shareFn =>
      bridge.shareOpaqueMutexBTreeMapKeyIdStreamSinkTxState;

  @override
  OpaqueTypeFinalizer get staticFinalizer =>
      bridge.MutexBTreeMapKeyIdStreamSinkTxStateFinalizer;
}

@sealed
class MutexCrateWalletWallet extends FrbOpaque {
  final Native bridge;
  MutexCrateWalletWallet.fromRaw(int ptr, int size, this.bridge)
      : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueMutexCrateWalletWallet;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueMutexCrateWalletWallet;

  @override
  OpaqueTypeFinalizer get staticFinalizer =>
      bridge.MutexCrateWalletWalletFinalizer;
}

@sealed
class PortBytesToReadSender extends FrbOpaque {
  final Native bridge;
  PortBytesToReadSender.fromRaw(int ptr, int size, this.bridge)
      : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaquePortBytesToReadSender;

  @override
  ShareFnType get shareFn => bridge.shareOpaquePortBytesToReadSender;

  @override
  OpaqueTypeFinalizer get staticFinalizer =>
      bridge.PortBytesToReadSenderFinalizer;
}

@sealed
class PortOpenSender extends FrbOpaque {
  final Native bridge;
  PortOpenSender.fromRaw(int ptr, int size, this.bridge)
      : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaquePortOpenSender;

  @override
  ShareFnType get shareFn => bridge.shareOpaquePortOpenSender;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.PortOpenSenderFinalizer;
}

@sealed
class PortReadSender extends FrbOpaque {
  final Native bridge;
  PortReadSender.fromRaw(int ptr, int size, this.bridge)
      : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaquePortReadSender;

  @override
  ShareFnType get shareFn => bridge.shareOpaquePortReadSender;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.PortReadSenderFinalizer;
}

@sealed
class PortWriteSender extends FrbOpaque {
  final Native bridge;
  PortWriteSender.fromRaw(int ptr, int size, this.bridge)
      : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaquePortWriteSender;

  @override
  ShareFnType get shareFn => bridge.shareOpaquePortWriteSender;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.PortWriteSenderFinalizer;
}

@sealed
class RTransaction extends FrbOpaque {
  final Native bridge;
  RTransaction.fromRaw(int ptr, int size, this.bridge)
      : super.unsafe(ptr, size);
  @override
  DropFnType get dropFn => bridge.dropOpaqueRTransaction;

  @override
  ShareFnType get shareFn => bridge.shareOpaqueRTransaction;

  @override
  OpaqueTypeFinalizer get staticFinalizer => bridge.RTransactionFinalizer;
}

class Address {
  final int index;
  final String addressString;
  final bool used;

  const Address({
    required this.index,
    required this.addressString,
    required this.used,
  });
}

class ConfirmationTime {
  final int height;
  final int time;

  const ConfirmationTime({
    required this.height,
    required this.time,
  });
}

class Coordinator {
  final Native bridge;
  final FfiCoordinator field0;

  const Coordinator({
    required this.bridge,
    required this.field0,
  });

  Future<void> startThread({dynamic hint}) =>
      bridge.startThreadMethodCoordinator(
        that: this,
      );

  Future<void> updateNamePreview(
          {required DeviceId id, required String name, dynamic hint}) =>
      bridge.updateNamePreviewMethodCoordinator(
        that: this,
        id: id,
        name: name,
      );

  Future<void> finishNaming(
          {required DeviceId id, required String name, dynamic hint}) =>
      bridge.finishNamingMethodCoordinator(
        that: this,
        id: id,
        name: name,
      );

  Future<void> sendCancel({required DeviceId id, dynamic hint}) =>
      bridge.sendCancelMethodCoordinator(
        that: this,
        id: id,
      );

  Future<void> cancelAll({dynamic hint}) => bridge.cancelAllMethodCoordinator(
        that: this,
      );

  KeyState keyState({dynamic hint}) => bridge.keyStateMethodCoordinator(
        that: this,
      );

  FrostKey? getKey({required KeyId keyId, dynamic hint}) =>
      bridge.getKeyMethodCoordinator(
        that: this,
        keyId: keyId,
      );

  Stream<SigningState> startSigning(
          {required KeyId keyId,
          required List<DeviceId> devices,
          required String message,
          dynamic hint}) =>
      bridge.startSigningMethodCoordinator(
        that: this,
        keyId: keyId,
        devices: devices,
        message: message,
      );

  SigningState? getSigningState({dynamic hint}) =>
      bridge.getSigningStateMethodCoordinator(
        that: this,
      );

  int noncesAvailable({required DeviceId id, dynamic hint}) =>
      bridge.noncesAvailableMethodCoordinator(
        that: this,
        id: id,
      );

  Stream<CoordinatorToUserKeyGenMessage> generateNewKey(
          {required int threshold,
          required List<DeviceId> devices,
          dynamic hint}) =>
      bridge.generateNewKeyMethodCoordinator(
        that: this,
        threshold: threshold,
        devices: devices,
      );

  bool canRestoreSigningSession({required KeyId keyId, dynamic hint}) =>
      bridge.canRestoreSigningSessionMethodCoordinator(
        that: this,
        keyId: keyId,
      );

  Stream<SigningState> tryRestoreSigningSession(
          {required KeyId keyId, dynamic hint}) =>
      bridge.tryRestoreSigningSessionMethodCoordinator(
        that: this,
        keyId: keyId,
      );
}

@freezed
sealed class CoordinatorToUserKeyGenMessage
    with _$CoordinatorToUserKeyGenMessage {
  const factory CoordinatorToUserKeyGenMessage.receivedShares({
    required DeviceId from,
  }) = CoordinatorToUserKeyGenMessage_ReceivedShares;
  const factory CoordinatorToUserKeyGenMessage.checkKeyGen({
    required U8Array32 sessionHash,
  }) = CoordinatorToUserKeyGenMessage_CheckKeyGen;
  const factory CoordinatorToUserKeyGenMessage.keyGenAck({
    required DeviceId from,
  }) = CoordinatorToUserKeyGenMessage_KeyGenAck;
  const factory CoordinatorToUserKeyGenMessage.finishedKey({
    required KeyId keyId,
  }) = CoordinatorToUserKeyGenMessage_FinishedKey;
}

class Device {
  final String? name;
  final DeviceId id;

  const Device({
    this.name,
    required this.id,
  });
}

class DeviceId {
  final U8Array33 field0;

  const DeviceId({
    required this.field0,
  });
}

class DeviceListChange {
  final DeviceListChangeKind kind;
  final int index;
  final Device device;

  const DeviceListChange({
    required this.kind,
    required this.index,
    required this.device,
  });
}

enum DeviceListChangeKind {
  Added,
  Removed,
  Named,
}

class DeviceListState {
  final Native bridge;
  final List<Device> devices;
  final int stateId;

  const DeviceListState({
    required this.bridge,
    required this.devices,
    required this.stateId,
  });

  List<DeviceId> namedDevices({dynamic hint}) =>
      bridge.namedDevicesMethodDeviceListState(
        that: this,
      );
}

class DeviceListUpdate {
  final List<DeviceListChange> changes;
  final DeviceListState state;

  const DeviceListUpdate({
    required this.changes,
    required this.state,
  });
}

class EncodedSignature {
  final U8Array64 field0;

  const EncodedSignature({
    required this.field0,
  });
}

class FfiSerial {
  final Native bridge;
  final ArcMutexVecPortDesc availablePorts;

  const FfiSerial({
    required this.bridge,
    required this.availablePorts,
  });

  Future<void> setAvailablePorts(
          {required List<PortDesc> ports, dynamic hint}) =>
      bridge.setAvailablePortsMethodFfiSerial(
        that: this,
        ports: ports,
      );
}

class FrostKey {
  final Native bridge;
  final FrostsnapCoreCoordinatorFrostKeyState field0;

  const FrostKey({
    required this.bridge,
    required this.field0,
  });

  int threshold({dynamic hint}) => bridge.thresholdMethodFrostKey(
        that: this,
      );

  KeyId id({dynamic hint}) => bridge.idMethodFrostKey(
        that: this,
      );

  String name({dynamic hint}) => bridge.nameMethodFrostKey(
        that: this,
      );

  List<Device> devices({dynamic hint}) => bridge.devicesMethodFrostKey(
        that: this,
      );
}

class KeyId {
  final U8Array32 field0;

  const KeyId({
    required this.field0,
  });
}

class KeyState {
  final List<FrostKey> keys;

  const KeyState({
    required this.keys,
  });
}

enum Level {
  Debug,
  Info,
}

class PortBytesToRead {
  final Native bridge;
  final String id;
  final PortBytesToReadSender ready;

  const PortBytesToRead({
    required this.bridge,
    required this.id,
    required this.ready,
  });

  Future<void> satisfy({required int bytesToRead, dynamic hint}) =>
      bridge.satisfyMethodPortBytesToRead(
        that: this,
        bytesToRead: bytesToRead,
      );
}

class PortDesc {
  final String id;
  final int vid;
  final int pid;

  const PortDesc({
    required this.id,
    required this.vid,
    required this.pid,
  });
}

@freezed
sealed class PortEvent with _$PortEvent {
  const factory PortEvent.open({
    required PortOpen request,
  }) = PortEvent_Open;
  const factory PortEvent.write({
    required PortWrite request,
  }) = PortEvent_Write;
  const factory PortEvent.read({
    required PortRead request,
  }) = PortEvent_Read;
  const factory PortEvent.bytesToRead({
    required PortBytesToRead request,
  }) = PortEvent_BytesToRead;
}

class PortOpen {
  final Native bridge;
  final String id;
  final int baudRate;
  final PortOpenSender ready;

  const PortOpen({
    required this.bridge,
    required this.id,
    required this.baudRate,
    required this.ready,
  });

  Future<void> satisfy({String? err, dynamic hint}) =>
      bridge.satisfyMethodPortOpen(
        that: this,
        err: err,
      );
}

class PortRead {
  final Native bridge;
  final String id;
  final int len;
  final PortReadSender ready;

  const PortRead({
    required this.bridge,
    required this.id,
    required this.len,
    required this.ready,
  });

  Future<void> satisfy({required Uint8List bytes, String? err, dynamic hint}) =>
      bridge.satisfyMethodPortRead(
        that: this,
        bytes: bytes,
        err: err,
      );
}

class PortWrite {
  final Native bridge;
  final String id;
  final Uint8List bytes;
  final PortWriteSender ready;

  const PortWrite({
    required this.bridge,
    required this.id,
    required this.bytes,
    required this.ready,
  });

  Future<void> satisfy({String? err, dynamic hint}) =>
      bridge.satisfyMethodPortWrite(
        that: this,
        err: err,
      );
}

class SigningState {
  final Native bridge;
  final List<DeviceId> gotShares;
  final List<DeviceId> neededFrom;
  final List<EncodedSignature> finishedSignatures;

  const SigningState({
    required this.bridge,
    required this.gotShares,
    required this.neededFrom,
    required this.finishedSignatures,
  });

  bool isFinished({dynamic hint}) => bridge.isFinishedMethodSigningState(
        that: this,
      );
}

class Transaction {
  final Native bridge;
  final int netValue;
  final RTransaction inner;
  final ConfirmationTime? confirmationTime;

  const Transaction({
    required this.bridge,
    required this.netValue,
    required this.inner,
    this.confirmationTime,
  });

  String txid({dynamic hint}) => bridge.txidMethodTransaction(
        that: this,
      );
}

class TxState {
  final List<Transaction> txs;

  const TxState({
    required this.txs,
  });
}

class U8Array32 extends NonGrowableListView<int> {
  static const arraySize = 32;
  U8Array32(Uint8List inner)
      : assert(inner.length == arraySize),
        super(inner);
  U8Array32.unchecked(Uint8List inner) : super(inner);
  U8Array32.init() : super(Uint8List(arraySize));
}

class U8Array33 extends NonGrowableListView<int> {
  static const arraySize = 33;
  U8Array33(Uint8List inner)
      : assert(inner.length == arraySize),
        super(inner);
  U8Array33.unchecked(Uint8List inner) : super(inner);
  U8Array33.init() : super(Uint8List(arraySize));
}

class U8Array64 extends NonGrowableListView<int> {
  static const arraySize = 64;
  U8Array64(Uint8List inner)
      : assert(inner.length == arraySize),
        super(inner);
  U8Array64.unchecked(Uint8List inner) : super(inner);
  U8Array64.init() : super(Uint8List(arraySize));
}

class Wallet {
  final Native bridge;
  final MutexCrateWalletWallet inner;
  final MutexBTreeMapKeyIdStreamSinkTxState walletStreams;
  final ChainSync chainSync;

  const Wallet({
    required this.bridge,
    required this.inner,
    required this.walletStreams,
    required this.chainSync,
  });

  Stream<TxState> subTxState({required KeyId keyId, dynamic hint}) =>
      bridge.subTxStateMethodWallet(
        that: this,
        keyId: keyId,
      );

  TxState txState({required KeyId keyId, dynamic hint}) =>
      bridge.txStateMethodWallet(
        that: this,
        keyId: keyId,
      );

  Stream<double> syncTxids(
          {required KeyId keyId, required List<String> txids, dynamic hint}) =>
      bridge.syncTxidsMethodWallet(
        that: this,
        keyId: keyId,
        txids: txids,
      );

  Stream<double> sync({required KeyId keyId, dynamic hint}) =>
      bridge.syncMethodWallet(
        that: this,
        keyId: keyId,
      );

  Future<Address> nextAddress({required KeyId keyId, dynamic hint}) =>
      bridge.nextAddressMethodWallet(
        that: this,
        keyId: keyId,
      );

  List<Address> addressesState({required KeyId keyId, dynamic hint}) =>
      bridge.addressesStateMethodWallet(
        that: this,
        keyId: keyId,
      );
}
