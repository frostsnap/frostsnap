use super::{Column, Container, HoldToConfirm, Padding, Row, Text, Widget};
use crate::super_draw_target::SuperDrawTarget;
use crate::{palette::PALETTE, Instant, MainAxisAlignment};
use alloc::format;
use embedded_graphics::{
    draw_target::DrawTarget,
    geometry::{Point, Size},
    pixelcolor::Rgb565,
    text::Alignment,
};
use u8g2_fonts::U8g2TextStyle;

type CodeText = Text<U8g2TextStyle<Rgb565>>;
type TofNText = Text<U8g2TextStyle<Rgb565>>;
type CodeColumn = Column<(TofNText, CodeText)>;
type PaddedCodeColumn = Padding<CodeColumn>;
type CodeContainer = Container<PaddedCodeColumn>;
type ConfirmText = Text<U8g2TextStyle<Rgb565>>;
type PromptColumn = Column<(ConfirmText, CodeContainer, ConfirmText)>;

/// Widget for checking and confirming key generation
#[derive(frostsnap_macros::Widget)]
pub struct KeygenCheck {
    /// The hold-to-confirm widget
    #[widget_delegate]
    hold_to_confirm: HoldToConfirm<PromptColumn>,
}

impl KeygenCheck {
    /// Create a new keygen check widget
    pub fn new(t_of_n: (u16, u16), security_check_code: [u8; 4]) -> Self {
        // Format the t of n string
        let t_of_n_text = format!("{} of {}", t_of_n.0, t_of_n.1);

        // Format the security check code as hex
        let hex_code = format!(
            "{:02x}{:02x} {:02x}{:02x}",
            security_check_code[0],
            security_check_code[1],
            security_check_code[2],
            security_check_code[3]
        );

        // Create the t of n text widget in blue
        let t_of_n_style = U8g2TextStyle::new(crate::FONT_MED, PALETTE.primary);
        let t_of_n_widget = Text::new(t_of_n_text.clone(), t_of_n_style.clone());

        // Create the hex code text widget using FONT_LARGE in blue
        let code_style = U8g2TextStyle::new(crate::FONT_LARGE, PALETTE.primary);
        let code_widget = Text::new(hex_code.clone(), code_style);

        // Create internal column with t_of_n and code
        let code_column = Column::new((t_of_n_widget, code_widget));

        // Put the column in a container with a border (no fill for cleaner look)
        let padded_code_column = Padding::all(10, code_column);
        let code_container = Container::new(padded_code_column)
            .with_border(PALETTE.outline, 2)
            .with_corner_radius(Size::new(8, 8));

        // Create the subtitle text in smaller grey (now at the top)
        let subtitle_style = U8g2TextStyle::new(crate::FONT_SMALL, PALETTE.text_secondary);
        let subtitle_text = Text::new(
            "Check this code matches\non every device",
            subtitle_style
        ).with_alignment(Alignment::Center);

        // Create the main title "Hold to Confirm" (now at the bottom)
        let title_style = U8g2TextStyle::new(crate::FONT_MED, PALETTE.on_background);
        let title_text = Text::new("Hold to Confirm", title_style);

        // Create the prompt column with SpaceEvenly alignment
        let prompt_column = Column::new((subtitle_text, code_container, title_text))
            .with_main_axis_alignment(MainAxisAlignment::SpaceEvenly);

        // Create the hold-to-confirm widget
        let hold_to_confirm = HoldToConfirm::new(
            2000, // 2 second hold duration
            prompt_column,
        );

        Self {
            hold_to_confirm,
        }
    }

    /// Check if the user has confirmed
    pub fn is_confirmed(&self) -> bool {
        self.hold_to_confirm.is_completed()
    }

    /// Reset the confirmation state
    pub fn reset(&mut self) {
        self.hold_to_confirm.reset();
    }
}

// All trait implementations are now generated by the derive macro
