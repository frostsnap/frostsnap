use super::{Column, Text as TextWidget, Widget};
use crate::super_draw_target::SuperDrawTarget;
use crate::{
    alignment::{Align, HorizontalAlignment},
    bitmap::EncodedImage, image::Image, palette::PALETTE, vec_framebuffer::VecFramebuffer,
    Instant, Switcher,
};
use alloc::string::String;
use embedded_graphics::text::Alignment;
use embedded_graphics::{
    draw_target::DrawTarget,
    geometry::{Point, Size},
    pixelcolor::{BinaryColor, Rgb565},
};
use u8g2_fonts::U8g2TextStyle;

/// A widget for displaying device name with optional edit mode cursor

#[derive(frostsnap_macros::Widget)]
pub struct DeviceName {
    /// The device name text widget
    #[widget_delegate]
    text_widget: Switcher<Align<TextWidget<U8g2TextStyle<Rgb565>>>>,
}

impl DeviceName {
    /// Create a new device name widget
    pub fn new<S: Into<String>>(name: S) -> Self {
        let name_string = name.into();
        let char_style = U8g2TextStyle::new(crate::FONT_LARGE, PALETTE.primary);
        let text = TextWidget::new(name_string, char_style);
        let aligned_text = Align::new(text).horizontal(HorizontalAlignment::Center);
        let text_widget = Switcher::new(aligned_text);

        Self { text_widget }
    }

    /// Get the current name
    pub fn name(&self) -> &str {
        self.text_widget.current().child.text()
    }

    /// Set a new device name
    pub fn set_name<S: Into<String>>(&mut self, name: S) {
        let name_string = name.into();
        let char_style = U8g2TextStyle::new(crate::FONT_LARGE, PALETTE.primary);
        let text = TextWidget::new(name_string, char_style);
        let aligned_text = Align::new(text).horizontal(HorizontalAlignment::Center);
        self.text_widget.switch_to(aligned_text);
    }
}

const LOGO_DATA: &[u8] = include_bytes!("../assets/frostsnap-logo-96x96.bin");

/// A screen showing the Frostsnap logo and the DeviceName widget
#[derive(frostsnap_macros::Widget)]
pub struct DeviceNameScreen {
    #[widget_delegate]
    column: Column<(Image<VecFramebuffer<BinaryColor>, Rgb565>, DeviceName)>,
}

impl DeviceNameScreen {
    /// Get a reference to the inner DeviceName widget
    fn device_name_widget(&self) -> &DeviceName {
        &self.column.children.1
    }

    /// Get a mutable reference to the inner DeviceName widget
    fn device_name_widget_mut(&mut self) -> &mut DeviceName {
        &mut self.column.children.1
    }

    pub fn new(device_name: String) -> Self {
        // Load logo
        let encoded_image = EncodedImage::from_bytes(LOGO_DATA).expect("Failed to load logo");
        let framebuffer: VecFramebuffer<BinaryColor> = encoded_image.into();
        let logo_colored = Image::with_color_map(framebuffer, |c| match c {
            BinaryColor::On => PALETTE.logo,
            BinaryColor::Off => PALETTE.background,
        });

        // Create DeviceName widget
        let device_name_widget = DeviceName::new(device_name);

        // Create the column with main axis alignment for spacing
        let column = Column::new((logo_colored, device_name_widget))
            .with_main_axis_alignment(crate::MainAxisAlignment::SpaceEvenly);

        Self { column }
    }

    /// Get the current device name
    pub fn name(&self) -> &str {
        self.device_name_widget().name()
    }

    /// Set a new device name
    pub fn set_name<S: Into<String>>(&mut self, name: S) {
        self.device_name_widget_mut().set_name(name);
    }
}

// All trait implementations are now generated by the derive macro
