use crate::{palette::PALETTE, text::Text, Column, MainAxisAlignment, Row};
use alloc::{
    string::{String, ToString},
    vec::Vec,
};
use embedded_graphics::pixelcolor::Rgb565;
use u8g2_fonts::U8g2TextStyle;

// Type alias for a row with three text chunks
type AddressRow = Row<(
    Text<U8g2TextStyle<Rgb565>>,
    Text<U8g2TextStyle<Rgb565>>,
    Text<U8g2TextStyle<Rgb565>>,
)>;

/// A widget for displaying P2TR (Taproot) addresses in a specific format:
/// - 1 row with the first chunk (grayed out)
/// - 5 rows with 3 chunks each (4 chars per chunk)
/// - Total: 62 characters displayed as 16 chunks
#[derive(frostsnap_macros::Widget)]
pub struct P2trAddressDisplay {
    #[widget_delegate]
    column: Column<(
        Row<(Text<U8g2TextStyle<Rgb565>>,)>,
        AddressRow,
        AddressRow,
        AddressRow,
        AddressRow,
        AddressRow,
    )>,
}

impl P2trAddressDisplay {
    pub fn new(address: &str) -> Self {
        // P2TR addresses are always 62 characters (ASCII)
        // Split into chunks of 4 characters, padding with spaces as needed
        let chunks: Vec<String> = (0..address.len())
            .step_by(4)
            .map(|start| {
                let end = (start + 4).min(address.len());
                let chunk = &address[start..end];
                // Pad to 4 characters with spaces
                format!("{:4}", chunk)
            })
            .collect();

        // Use a light grey color for the address text
        let text_style = U8g2TextStyle::new(crate::FONT_LARGE, PALETTE.on_surface);

        // First chunk on its own row (grayed out)
        let type_indicator = Row::new((Text::new(chunks[0].clone(), text_style.clone()),));

        // Create an iterator that produces rows of 3 chunks each
        let mut row_iter = chunks[1..].chunks(3).map(|row_chunks| {
            Row::new((
                Text::new(row_chunks[0].clone(), text_style.clone()),
                Text::new(row_chunks[1].clone(), text_style.clone()),
                Text::new(row_chunks[2].clone(), text_style.clone()),
            ))
            .with_main_axis_alignment(MainAxisAlignment::SpaceAround)
        });

        // Get the 5 rows
        let row0 = row_iter.next().unwrap();
        let row1 = row_iter.next().unwrap();
        let row2 = row_iter.next().unwrap();
        let row3 = row_iter.next().unwrap();
        let row4 = row_iter.next().unwrap();

        // Create column with all rows
        let column = Column::new((type_indicator, row0, row1, row2, row3, row4));

        Self { column }
    }
}

// All trait implementations are now generated by the derive macro
