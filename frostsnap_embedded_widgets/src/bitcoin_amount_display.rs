use crate::{palette::PALETTE, rat::FatRat, sized_box::SizedBox, text::Text, Row};
use alloc::string::ToString;
use embedded_graphics::{geometry::Size, pixelcolor::Rgb565};
use u8g2_fonts::U8g2TextStyle;

// Type alias to reduce complexity
type BitcoinAmountRow = Row<(
    Text<U8g2TextStyle<Rgb565>>, // Whole part + decimal point
    Text<U8g2TextStyle<Rgb565>>, // First decimal digit
    Text<U8g2TextStyle<Rgb565>>, // Second decimal digit
    SizedBox<Rgb565>,            // Half-width space
    Text<U8g2TextStyle<Rgb565>>, // Third decimal digit
    Text<U8g2TextStyle<Rgb565>>, // Fourth decimal digit
    Text<U8g2TextStyle<Rgb565>>, // Fifth decimal digit
    SizedBox<Rgb565>,            // Half-width space
    Text<U8g2TextStyle<Rgb565>>, // Sixth decimal digit
    Text<U8g2TextStyle<Rgb565>>, // Seventh decimal digit
    Text<U8g2TextStyle<Rgb565>>, // Eighth decimal digit
)>;

/// A widget that displays a Bitcoin amount with proper formatting and coloring
/// Displays in format: X.XX XXX XXX with half-width spaces between segments
#[derive(frostsnap_macros::Widget)]
pub struct BitcoinAmountDisplay {
    /// The row containing all elements - delegated by the derive macro
    #[widget_delegate]
    row: BitcoinAmountRow,
    /// Amount in satoshis (for reference)
    satoshis: u64,
}

impl BitcoinAmountDisplay {
    pub fn new(satoshis: u64) -> Self {
        let btc = FatRat::from_ratio(satoshis, 100_000_000);
        let amount_str = format!("{}.", btc.whole_part());
        let mut color = PALETTE.text_disabled;
        if btc.whole_part() > 0 {
            color = PALETTE.primary;
        }
        let whole_text = Text::new(amount_str, U8g2TextStyle::new(crate::FONT_LARGE, color));

        // Get decimal digits iterator (take only 8 for Bitcoin)
        let mut after_decimal = btc.decimal_digits().take(8).map(|digit| {
            if digit > 0 {
                color = PALETTE.primary;
            }
            Text::new(
                digit.to_string(),
                U8g2TextStyle::new(crate::FONT_LARGE, color),
            )
        });

        // Half-width spacers (approximately half the width of a digit)
        let spacer1 = SizedBox::<Rgb565>::new(Size::new(4, 1));
        let spacer2 = SizedBox::<Rgb565>::new(Size::new(4, 1));

        // Create row with all elements
        let row = Row::new((
            whole_text,
            after_decimal.next().unwrap(),
            after_decimal.next().unwrap(),
            spacer1,
            after_decimal.next().unwrap(),
            after_decimal.next().unwrap(),
            after_decimal.next().unwrap(),
            spacer2,
            after_decimal.next().unwrap(),
            after_decimal.next().unwrap(),
            after_decimal.next().unwrap(),
        ));

        Self { row, satoshis }
    }

    pub fn satoshis(&self) -> u64 {
        self.satoshis
    }
}

// All trait implementations are now generated by the derive macro
